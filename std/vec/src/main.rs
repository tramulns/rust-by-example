fn main() {
    // Итераторы могут быть собраны в вектора
    let collected_iterator: Vec<i32> = (0..10).collect();
    println!("(0..10) собраны в: {:?}", collected_iterator);

    // Макрос `vec!` может быть использован для инициализации вектора
    let mut xs = vec![1i32, 2, 3];
    println!("Исходный вектор: {:?}", xs);

    // Вставка нового элемента в конец вектора
    println!("Добавим 4 в конец вектора");
    xs.push(4);
    println!("Вектор: {:?}", xs);

    // Ошибка! Неизменяемые вектора не могут увеличиваться
    // collected_iterator.push(0);

    // Метод `len` отдаёт количество элементом, сохранённых в векторе
    println!("Длина вектора: {}", xs.len());

    // Индексация выполняется при помощи квадратных скобок (индексация начинается с 0)
    println!("Второй элемент: {}", xs[1]);

    // `pop` удаляет последний элемент из вектора и возвращает его
    println!("Последний элемент: {:?}", xs.pop());

    // Выход за пределы индексации вызывает панику
    println!("Четвёртый элемент: {}", xs[2]);
    // ИСПРАВЬТЕ ^ Закомментируйте эту строку

    // По векторами легко итерироваться
    println!("Содержимое `xs`:");
    for x in xs.iter() {
        println!("> {}", x);
    }

    // Также можно итерироваться по вектору с получением индекса элемента
    // (который будет содержаться в отдельной переменной `i`)
    for (i, x) in xs.iter().enumerate() {
        println!("{}-ый элемент имеет значение {}", i, x);
    }

    // Благодаря `iter_mut`, у изменяемых векторов можно менять значения
    // во время итерирования
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!("Обновлённый вектор: {:?}", xs);
}
